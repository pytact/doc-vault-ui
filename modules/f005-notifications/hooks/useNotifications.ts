/**
 * Notification Hooks
 * Based on R5-Custom Hooks and R9-Caching rules
 */

import {
  useQuery,
  useMutation,
  useQueryClient,
  keepPreviousData,
} from "@tanstack/react-query";
import { NotificationService } from "@/services/notifications/notification.service";
import { NotificationListParams } from "../types/requests/notification";
import {
  NotificationListResponse,
  NotificationMarkReadResponse,
  NotificationMarkAllReadResponse,
  UpcomingExpiryListResponse,
} from "../types/responses/notification";

/**
 * Notification list query hook
 * GET /v1/notifications
 * 
 * Returns paginated list of notifications for the current authenticated user.
 * Sorted by createdAt DESC by default.
 * Returns only notifications for Owner and FamilyAdmin roles.
 * 
 * @param params - Query parameters for pagination and sorting
 * @returns React Query result with paginated notification list
 */
export function useListNotifications(params?: NotificationListParams) {
  return useQuery({
    queryKey: [
      "notifications",
      params?.page,
      params?.page_size,
      params?.sort_by,
      params?.sort_order,
    ],
    queryFn: () => NotificationService.list(params),
    staleTime: 30_000, // 30 seconds - lists update frequently (R9: List Data = 30 seconds)
    gcTime: 5 * 60 * 1000, // 5 minutes (R9: Standard gcTime)
    placeholderData: keepPreviousData, // Keep previous data while fetching new page (R9: Pagination)
    refetchOnWindowFocus: false, // Prevent unnecessary refetches
  });
}

/**
 * Get notification by ID query hook
 * 
 * NOTE: Individual notification retrieval (GET /v1/notifications/{notification_id}) 
 * is NOT provided by the API. Clients should use the list endpoint and filter by ID 
 * if needed, or access notification details through the document link.
 * 
 * This hook is included for type consistency with R5 rules but will always throw an error.
 * 
 * @param notificationId - Notification UUID
 * @returns React Query result (will always error)
 */
export function useGetNotification(notificationId: string | null) {
  return useQuery({
    queryKey: ["notification", notificationId],
    queryFn: async () => {
      if (!notificationId) throw new Error("Notification ID is required");
      return NotificationService.getById(notificationId);
    },
    enabled: false, // Always disabled since endpoint doesn't exist
    staleTime: 0,
    gcTime: 0,
  });
}

/**
 * Create notification mutation hook
 * 
 * NOTE: Notifications are NOT created via API - they are automatically generated 
 * by the daily scheduler at 00:00 UTC. This hook is included for type consistency 
 * with R5 rules but will always throw an error.
 * 
 * @returns React Query mutation (will always error)
 */
export function useCreateNotification() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async () => {
      throw new Error(
        "Notifications cannot be created via API. They are automatically generated by the scheduler."
      );
    },
    onSuccess: () => {
      // Invalidate notification list queries (if operation were to succeed)
      queryClient.invalidateQueries({ queryKey: ["notifications"] });
    },
  });
}

/**
 * Update notification mutation hook
 * 
 * NOTE: Notifications are NOT updated via API. The only update operation available 
 * is marking as read (use useMarkNotificationAsRead() instead). This hook is included 
 * for type consistency with R5 rules but will always throw an error.
 * 
 * @returns React Query mutation (will always error)
 */
export function useUpdateNotification() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async () => {
      return NotificationService.update();
    },
    onSuccess: () => {
      // Invalidate notification list queries (if operation were to succeed)
      queryClient.invalidateQueries({ queryKey: ["notifications"] });
    },
  });
}

/**
 * Delete notification mutation hook
 * 
 * NOTE: Notifications are NOT deleted via API. They are automatically soft-deleted 
 * after 90 days by a cleanup job. This hook is included for type consistency with 
 * R5 rules but will always throw an error.
 * 
 * @returns React Query mutation (will always error)
 */
export function useDeleteNotification() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (notificationId: string) => {
      throw new Error(
        "Notifications cannot be deleted via API. They are automatically soft-deleted after 90 days."
      );
    },
    onSuccess: (data, variables) => {
      // Invalidate notification list queries to remove deleted notification from list
      queryClient.invalidateQueries({ queryKey: ["notifications"] });
      // Remove specific notification from cache (if operation were to succeed)
      queryClient.removeQueries({ queryKey: ["notification", variables] });
    },
  });
}

/**
 * Mark a single notification as read mutation hook
 * PATCH /v1/notifications/{notification_id}/read
 * 
 * Marks a single notification as read for the current authenticated user.
 * Requires ETag for concurrency control (from notification's updated_at).
 * 
 * @returns React Query mutation with cache invalidation
 */
export function useMarkNotificationAsRead() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      notificationId,
      etag,
    }: {
      notificationId: string;
      etag?: string;
    }) => NotificationService.markAsRead(notificationId, etag),
    onSuccess: (data, variables) => {
      // Invalidate notification list queries to refresh the list (mark as read changes is_read status)
      queryClient.invalidateQueries({ queryKey: ["notifications"] });
      // Invalidate specific notification query if it exists
      queryClient.invalidateQueries({ queryKey: ["notification", variables.notificationId] });
      // Invalidate upcoming expiries (notification read status might affect dashboard)
      queryClient.invalidateQueries({ queryKey: ["upcoming-expiries"] });
    },
  });
}

/**
 * Mark all notifications as read mutation hook
 * PATCH /v1/notifications/read-all
 * 
 * Marks all notifications as read for the current authenticated user.
 * No request body required. No ETag required.
 * 
 * @returns React Query mutation with cache invalidation
 */
export function useMarkAllNotificationsAsRead() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: () => NotificationService.markAllAsRead(),
    onSuccess: () => {
      // Invalidate notification list queries to refresh the list (all marked as read)
      queryClient.invalidateQueries({ queryKey: ["notifications"] });
      // Invalidate upcoming expiries (notification read status might affect dashboard)
      queryClient.invalidateQueries({ queryKey: ["upcoming-expiries"] });
    },
  });
}

/**
 * Upcoming expiries query hook
 * GET /v1/notifications/upcoming-expiries
 * 
 * Returns list of documents expiring within the next 30 days for dashboard widget.
 * Owner sees only their own documents.
 * FamilyAdmin sees all documents in the family.
 * 
 * @returns React Query result with upcoming expiries list
 */
export function useGetUpcomingExpiries() {
  return useQuery({
    queryKey: ["upcoming-expiries"],
    queryFn: () => NotificationService.getUpcomingExpiries(),
    staleTime: 30_000, // 30 seconds - dashboard data updates frequently (R9: List Data = 30 seconds)
    gcTime: 5 * 60 * 1000, // 5 minutes (R9: Standard gcTime)
    refetchOnWindowFocus: true, // Refetch on focus to get latest expiry data (important for dashboard)
  });
}

